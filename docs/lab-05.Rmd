---
title: "Rasters & Remote Sensing"
author: "[Angus Watters](https://anguswg-ucsb.github.io/)"
subtitle: "Palo, Iowa flood - 2017"
output:
  mikedown::ucsb:
    toc: TRUE
    number_sections: FALSE
    code_folding: "hide"
---
<br>
<br>

```{r, message = FALSE, warning = FALSE, echo = FALSE}
library(rmarkdown)     # You need this library to run this template.
library(mikedown) 
```

## **Background:**

***

#### On September 26, 2016 the Cedar and Wapsipinicon rivers in Iowa experienced a torrent of water producing a flood wave that breached the riverbanks. The water level of the Cedar River measured ~20 feet — 8 feet above flood stage—near the city of Cedar Rapids. Palo, Iowa is a town upstream of Cedar Rapids and is comprised primarily of farmland, additionally they do not have a forecast location to give warning. I used rasters to create flood images and then applied thresholding, multiband Landsat imagery, and classification techniques to the images.

***



<br>
<br>

```{r, message = FALSE, warning = FALSE}
# Libraries
library(knitr)
library(units)
library(readxl)
library(sp)
library(raster) 
library(tidyverse) 
library(getlandsat) 
library(sf)
library(mapview)
library(raster)
library(osmdata)
```


<br>
<br>
<br>

```{r, message = FALSE, warning = FALSE, echo = FALSE}
bb = read_csv('../data/uscities.csv') %>%
  filter(city == 'Palo') %>%
  st_as_sf(coords = c('lng', 'lat'), crs = 4326) %>%
  st_transform(5070) %>%
  st_buffer(5000) %>%
  st_bbox() %>%
  st_as_sfc() %>%
  st_as_sf()

```

```{r, message = FALSE, warning = FALSE, echo = FALSE}
scenes = lsat_scenes()

bb_wgs = st_transform(bb, 4326) %>%  st_bbox()

down = scenes %>%
  filter(min_lat <= bb_wgs$ymin, max_lat >= bb_wgs$ymax, min_lon <= bb_wgs$xmin,
         max_lon >= bb_wgs$xmax,
         as.Date(acquisitionDate) == as.Date('2016-09-26'))

write.csv(down, file = '../data/palo-flood.csv', row.names = FALSE)
```


```{r, message = FALSE, warning = FALSE, echo = FALSE}
meta = read_csv('../data/palo-flood.csv')

files = lsat_scene_files(meta$download_url) %>%
  filter(grepl(paste0('B', 1:6, '.TIF$', collapse = '|'), file)) %>%
  arrange(file) %>%
  pull(file)
```



```{r, message = FALSE, warning = FALSE, echo = FALSE}
st = sapply(files, lsat_image)

s = stack(st) %>%
  setNames(c('Coastal', 'Blue', 'Green', 'Red', 'NIR', 'SWIR1')) 

```


```{r, message = FALSE, warning = FALSE, echo = FALSE}
cropper = bb %>% st_as_sf() %>%
  st_transform(crs(s))

r = crop(s, cropper)

```

## **Color stretch:**

***

#### When a color stretch is applied, the maximum and minimum colors in the images become the new range of colors. The result of the stretch is that the features being highlighted by the given RGB channel are more emphasized and clearly seen in the image.

***

<br>
<br>

```{r, message = FALSE, warning = FALSE, echo = FALSE, fig.align="center", fig.width=10, fig.height=8, fig.cap="**Figure 1:** (4, 3, 2) Natural color . This is the closest true image bandwith. It is also prone to atmospheric interference"}
nat_col = plotRGB(r, r = 4, g = 3, b = 2)
```

***
<br>
<br>
<br>



```{r, message = FALSE, warning = FALSE, echo = FALSE, fig.align="center", fig.width=10, fig.height=8, fig.cap="**Figure 2:** (5, 4, 3) Color infared with a lin color stretch. Color infared does a good job of differentiating different types of vegatation as well as the health of the vegetation."}
inf_NIR = plotRGB(r, r = 5, g = 4, b = 3, stretch = 'lin')
```

***
<br>
<br>
<br>

```{r, message = FALSE, warning = FALSE, echo = FALSE, fig.align="center", fig.width=10, fig.height=8, fig.cap="**Figure 3:** (5, 6, 4) False color with a histogram color stretch. False color is good at seperating water from land in an image."}
false_SWIR = plotRGB(r, r = 5, g = 6, b = 4, stretch = 'hist')
```

***
<br>
<br>
<br>

```{r, message = FALSE, warning = FALSE, echo = FALSE, fig.align="center", fig.width=10, fig.height=8, fig.cap="**Figure 4:** (6, 5, 2) False color for agriculture with a histogram color stretch. In this bandwith agricultural crops appear as a vibrant green, non-crop vegetation appears in a dull green, and bare earth appears in fuchsia."}

false_agr = plotRGB(r, r = 6, g = 5, b = 2, stretch = 'hist')

```

***
<br>
<br>
<br>
<br>

```{r, message = FALSE, warning = FALSE}
# NVDI
x = (r$NIR - r$Red)/ (r$NIR + r$Red)

ndvi_func = function(x) {
  ifelse(x < 0, 1, NA)
}

ndvi = calc(x, ndvi_func)

# NWDI
y = (r$Green - r$NIR)/ (r$NIR + r$Green)

nwdi_func = function(y) {
  ifelse(y > 0, 1, NA)
}

ndwi = calc(y, nwdi_func)

# MNDWI
z = (r$Green - r$SWIR1)/ (r$SWIR1 + r$Green)

mnwdi_func = function(z) {
  ifelse(z > 0, 1, NA)
}

mndwi = calc(z, mnwdi_func)

# WRI
a = (r$Green + r$Red)/ (r$SWIR1 + r$NIR)

wri_func = function(a) {
  ifelse(a > 1, 1, NA)
}

wri = calc(a, wri_func)

# SWI
b = (1)/ sqrt(r$Blue - r$SWIR1)

swi_func = function(b) {
  ifelse(b < 5, 1, NA)
}

swi = calc(b, swi_func)
```


```{r, message = FALSE, warning = FALSE, echo = FALSE}
water_features_stack = stack(ndvi, ndwi, mndwi, wri, swi) %>%
  setNames(c('NDVI', 'NDWI', 'MNDWI', 'WRI', 'SWI'))
plot(water_features_stack, col = "blue")
```

<br>
<br>

### **Image discussion:**

***

#### The NDVI, NDWI, and WRI images are the most similar in that they show a lesser amount of flooded area compared to the SWI and MNDWI images. The SWI image highlights a wider flood area buffering the river and also picks up on other flooded areas outside of the rivers natural channel.

<br>
<br>
<br>
<br>
<br>

```{r, message = FALSE, warning = FALSE, echo = FALSE}
set.seed(09052020)
```


```{r, message = FALSE, warning = FALSE, echo = FALSE}
v = getValues(r)
```


```{r, message = FALSE, warning = FALSE, echo = FALSE}
idx = which(!is.na(v))
v = na.omit(v)

E = kmeans(v, centers = 12)

new_raster = r$Coastal
values(new_raster) = NA
new_raster[idx] = E$cluster
```


## **Binary flood masks vs. k-means cluster raster**

***

```{r, message = FALSE, warning = FALSE, echo = FALSE}
tab_ndvi = table(values(ndvi), values(new_raster))
tab_ndwi = table(values(ndwi), values(new_raster))
tab_mndwi = table(values(mndwi), values(new_raster))
tab_wri = table(values(wri), values(new_raster))
tab_swi = table(values(swi), values(new_raster))
ndvi_mask = which.max(tab_ndvi[1,])

flood_func = function(x){
  ifelse(x == ndvi_mask, 1, NA)
}
new_raster_2 = calc(new_raster, flood_func)

final = addLayer(water_features_stack, new_raster_2)
final[is.na(final)] = 0
```



```{r, message = FALSE, warning = FALSE, echo = FALSE}
# Calculate total area of the flooded cells in each image

area_ndvi = (cellStats(ndvi, 'sum') * 900)
area_ndwi = (cellStats(ndwi, 'sum') * 900)
area_mndwi = (cellStats(mndwi, 'sum') * 900)
area_wri = (cellStats(wri, 'sum') * 900)
area_swi = (cellStats(swi, 'sum') * 900)
area_new_rast_2 = (cellStats(new_raster_2, 'sum') * 900)

area_df = data.frame(img_band = c('NDVI', 'NDWI', 'MNDWI', 'WRI', 'SWI', 'k-means'),
                      total_area = c(area_ndvi, area_ndwi, area_mndwi, area_wri, area_swi, area_new_rast_2))
kable(area_df, caption = 'Total flooded area' , col.names = c('Image band', 'Area(m^2^)'))
```
 
<br>
<br>
<br>

```{r, message = FALSE, warning = FALSE, echo = FALSE}
# Uncertainty
Uncertainty = sum(final)

# plot flood map
Uncertainty[is.na(Uncertainty)] = 0
mapview(Uncertainty, col = RColorBrewer::brewer.pal(blues9, 'Spectral'))
```






































